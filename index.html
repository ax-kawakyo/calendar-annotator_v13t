<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>カレンダーアノテーター</title>
  <style>
    /* 全体のスタイル */
    :root {
      --primary-color: #007bff;
      --border-color: #e0e0e0;
      --bg-light: #f4f7f9;
      --bg-white: #ffffff;
      --text-primary: #333;
      --text-secondary: #888;
      --text-sunday: #d9534f;
      --text-saturday: #428bca;
      --label-bg-default: #fffbe6;
      --popover-bg: #fff;
      --popover-shadow: rgba(0, 0, 0, 0.15);
      --danger-color: #dc3545;

      /* New button colors */
      --btn-blue-bg: #eaf4ff;
      --btn-blue-hover-bg: #d0e6ff;
      --btn-yellow-bg: #fff9e0;
      --btn-yellow-hover-bg: #fff2c2;
      --btn-brown-bg: #f4f0eb;
      --btn-brown-hover-bg: #e8e2d9;
      --btn-green-bg: #e6f8e6;
      --btn-green-hover-bg: #d1f0d1;
      --btn-red-bg: #ffebeb;
      --btn-red-hover-bg: #ffd6d6;
      --btn-purple-bg: #f3e8ff;
      --btn-purple-hover-bg: #e9d5ff;
      --btn-gray-bg: #f0f0f0;
      --btn-gray-hover-bg: #e0e0e0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      background-color: var(--bg-light);
      color: var(--text-primary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #root {
      display: flex;
      justify-content: center;
      padding: 20px;
    }
    .app-container {
      width: 100%;
      max-width: 1200px;
      min-width: 800px;
      background-color: var(--bg-white);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* ヘッダー */
    .header {
      padding: 16px 24px;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
    }
    .header-top {
      display: flex;
      align-items: center;
      gap: 24px;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
      flex-shrink: 0;
    }
    .id-control {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-grow: 1;
    }
    .id-control label {
        font-size: 1em;
        font-weight: 500;
        color: #555;
        white-space: nowrap;
    }
    .id-control input {
        border: 1px solid #ccc;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 0.9em;
        width: 100%;
    }
    .data-ops {
        display: flex;
        gap: 4px;
    }
    .data-ops button {
      background-color: var(--bg-white);
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 0.85em;
      transition: all 0.2s ease-in-out;
      white-space: nowrap;
    }
    .data-ops button:hover {
      background-color: #f0f0f0;
      border-color: #bbb;
      transform: translateY(-1px);
    }
     .data-ops button:active {
      background-color: #e0e0e0;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      transform: translateY(0);
    }
    
    /* Date Picker Popover */
    .date-picker-container {
      position: relative;
    }
    .header-title-btn {
      background-color: transparent;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out;
      font-size: 1.5em;
      font-weight: 600;
      color: #2c3e50;
      font-family: inherit;
      white-space: nowrap;
    }
    .header-title-btn:hover {
      background-color: #f0f0f0;
    }
    #date-picker-popover {
      position: absolute;
      top: calc(100% + 8px);
      left: 0;
      width: 280px;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      padding: 16px;
      z-index: 200;
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .date-picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .date-picker-header button {
      background: none;
      border: none;
      font-size: 1.2em;
      font-weight: bold;
      cursor: pointer;
      padding: 4px 12px;
      border-radius: 4px;
    }
    .date-picker-header button:hover {
      background-color: #f0f0f0;
    }
    #year-input {
      width: 80px;
      text-align: center;
      font-size: 1.1em;
      font-weight: 500;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 4px;
      -moz-appearance: textfield; /* Firefox */
    }
    #year-input::-webkit-outer-spin-button,
    #year-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .month-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .month-btn {
      padding: 10px;
      border-radius: 6px;
      border: 1px solid transparent;
      background-color: #f8f8f8;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9em;
    }
    .month-btn:hover {
      background-color: #eef7ff;
      border-color: var(--primary-color);
    }
    .month-btn.active {
      background-color: var(--primary-color);
      color: white;
      font-weight: bold;
    }
    .date-picker-footer {
      text-align: center;
      margin-top: 8px;
    }
    #date-picker-today-btn {
      width: 100%;
      padding: 10px;
      font-size: 1em;
      font-weight: 500;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #date-picker-today-btn:hover {
      background-color: #e0e0e0;
    }

    /* 装飾バー */
    .deco-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .deco-control label {
      font-size: 13px;
      color: #555;
    }
    .deco-control input[type="color"] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      background-color: transparent;
      border: none;
      cursor: pointer;
      padding: 0;
    }
    .deco-control input[type="color"]::-webkit-color-swatch {
      border-radius: 50%;
      border: 1px solid var(--border-color);
    }
    .style-btn-group button {
      background: var(--bg-white);
      border: 1px solid #ccc;
      font-size: 14px;
      padding: 4px 10px;
      cursor: pointer;
      pointer-events: all; /* クリックイベントを確実に拾う */
    }
    .style-btn-group button:first-child {
      border-radius: 4px 0 0 4px;
      border-right: none;
    }
    .style-btn-group button:last-child {
      border-radius: 0 4px 4px 0;
    }
    .style-btn-group button.active {
      background-color: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }


    /* カレンダーボード */
    .calendar-board {
      padding: 16px;
      flex-grow: 1;
    }
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 1px;
      background-color: var(--border-color);
      border: 1px solid var(--border-color);
      height: 100%;
      user-select: none; /* テキスト選択を防ぐ */
    }
    .day-header {
      text-align: center;
      padding: 10px 0;
      font-weight: 600;
      background-color: #f5f5f5;
    }
    .day-header.sunday { color: var(--text-sunday); }
    .day-header.saturday { color: var(--text-saturday); }

    /* 日付セル */
    .date-cell {
      position: relative;
      min-height: 120px;
      background-color: var(--bg-white);
      padding: 8px;
      transition: background-color 0.2s;
      display: flex;
      flex-direction: column;
      cursor: pointer;
    }
    .date-cell.other-month {
      background-color: #fdfdfd;
    }
    .date-cell.other-month .date-number {
      color: var(--text-secondary);
      opacity: 0.7;
    }
     .date-cell:hover {
        background-color: #eef7ff;
     }
     .date-cell.other-month:hover {
        background-color: #f5fafd;
     }

    .date-number {
      font-size: 0.9em;
      font-weight: 500;
      text-align: left;
      margin-bottom: 4px;
    }
    .date-number.sunday { color: var(--text-sunday); }
    .date-number.saturday { color: var(--text-saturday); }
    .date-number.today {
        background-color: var(--primary-color);
        color: var(--bg-white);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
    }
    .labels-container {
        flex-grow: 1;
        position: relative;
    }
    
    /* ラベル */
    .label {
      position: absolute;
      background-color: var(--label-bg-default);
      border: 1px solid transparent; /* 枠線を透明に変更 */
      border-radius: 4px;
      padding: 4px 22px 4px 6px; /* 右側にアイコン用のスペースを確保 */
      font-size: 0.85em;
      cursor: grab;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      z-index: 10;
      min-height: 20px;
      width: calc(100% - 30px); /* 親要素から少し内側に */
      word-wrap: break-word; /* テキストの折り返し */
    }
    .label.editing {
      outline: 2px solid var(--primary-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      z-index: 20;
      cursor: text;
    }
    .label.drag-ready {
      border: 2px solid var(--primary-color);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .label[contenteditable="true"]:focus {
      outline: none; /* editingクラスで制御するため */
    }
    .label.dragging {
      opacity: 0.7;
      cursor: grabbing;
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
      z-index: 999;
      width: auto; 
    }
    .label-link-icon {
        position: absolute;
        top: 50%;
        right: 4px;
        transform: translateY(-50%);
        width: 14px;
        height: 14px;
        cursor: pointer;
        z-index: 15;
    }
    .label-link-icon svg {
        display: block;
        width: 100%;
        height: 100%;
        fill: #555;
        transition: fill 0.2s;
    }
    .label-link-icon:hover svg {
        fill: var(--primary-color);
    }

    /* ポップオーバー */
    #popover {
      position: fixed;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--popover-shadow);
      padding: 0; /* Changed */
      display: flex;
      flex-direction: column; /* Changed */
      z-index: 100;
      border: 1px solid var(--border-color);
      transition: opacity 0.1s ease-in-out, transform 0.1s ease-in-out;
      max-width: 250px;
    }
    .popover-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border-color);
      font-weight: 500;
      font-size: 14px;
    }
    .popover-header .close-btn {
      background: none;
      border: none;
      font-size: 1.5em;
      cursor: pointer;
      line-height: 1;
      padding: 0 4px;
      color: #888;
    }
    .popover-header .close-btn:hover {
      color: #333;
    }
    .popover-content {
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .popover-btn {
        border: 1px solid #dcdcdc;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 13px;
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s;
    }
    .popover-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    /* --- Popover Button Colors --- */
    /* 決定 (save/update) / 選択 (select) - Light Blue */
    .popover-btn[data-action="save"],
    .popover-btn[data-action="update"],
    .popover-btn[data-action="select-template"],
    .popover-btn[data-action="open-link"] {
        background-color: var(--btn-blue-bg);
        border-color: #b8d6f5;
    }
    .popover-btn[data-action="save"]:hover:not(:disabled),
    .popover-btn[data-action="update"]:hover:not(:disabled),
    .popover-btn[data-action="select-template"]:hover:not(:disabled),
    .popover-btn[data-action="open-link"]:hover:not(:disabled) {
        background-color: var(--btn-blue-hover-bg);
    }

    /* 貼付 (paste) / 複写 (duplicate) - Light Yellow */
    .popover-btn[data-action="paste"],
    .popover-btn[data-action="duplicate"] {
        background-color: var(--btn-yellow-bg);
        border-color: #f0e0a4;
    }
    .popover-btn[data-action="paste"]:hover:not(:disabled),
    .popover-btn[data-action="duplicate"]:hover:not(:disabled) {
        background-color: var(--btn-yellow-hover-bg);
    }
    
    /* 呼出 (recall) - Light Brown */
    .popover-btn[data-action="recall"] {
        background-color: var(--btn-brown-bg);
        border-color: #dcd4c9;
    }
    .popover-btn[data-action="recall"]:hover:not(:disabled) {
        background-color: var(--btn-brown-hover-bg);
    }
    
    /* リンク (edit-link) - Gray */
    .popover-btn[data-action="edit-link"] {
        background-color: var(--btn-gray-bg);
        border-color: #cccccc;
    }
    .popover-btn[data-action="edit-link"]:hover:not(:disabled) {
        background-color: var(--btn-gray-hover-bg);
    }

    /* 閉じる (close-template) - Light Red */
    .popover-btn[data-action="close-template"] {
        background-color: var(--btn-red-bg);
        border-color: #f5c4c4;
    }
    .popover-btn[data-action="close-template"]:hover:not(:disabled) {
        background-color: var(--btn-red-hover-bg);
    }
    
    /* 装飾 (decorate) - Light Purple */
    .popover-btn[data-action="decorate"] {
        background-color: var(--btn-purple-bg);
        border-color: #d3b3ff;
    }
    .popover-btn[data-action="decorate"]:hover:not(:disabled) {
        background-color: var(--btn-purple-hover-bg);
    }

    /* テンプレ保存 (save-template) - Light Green */
    .popover-btn[data-action="save-template"] {
        background-color: var(--btn-green-bg);
        border-color: #b8e2b8;
    }
    .popover-btn[data-action="save-template"]:hover:not(:disabled) {
        background-color: var(--btn-green-hover-bg);
    }

    /* 削除 (delete/delete-template) - White bg, black border, red text */
    .popover-btn[data-action="delete"],
    .popover-btn[data-action="delete-template"] {
        background-color: #ffffff;
        color: var(--danger-color);
        border: 1px solid #333;
        font-weight: 500;
    }
    .popover-btn[data-action="delete"]:hover:not(:disabled),
    .popover-btn[data-action="delete-template"]:hover:not(:disabled) {
        background-color: var(--danger-color);
        color: white;
        border-color: var(--danger-color);
    }

    /* Decoration Popover */
    #decoration-popover {
      position: fixed;
      background-color: var(--popover-bg);
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--popover-shadow);
      padding: 12px;
      z-index: 101; /* Above main popover */
      border: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: 280px;
    }
    .deco-popover-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 500;
      font-size: 14px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }
    .deco-popover-header button {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        line-height: 1;
        padding: 0 4px;
        color: #888;
    }
    .deco-popover-header button:hover {
        color: #333;
    }
    .deco-popover-controls {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    .deco-popover-controls .deco-control {
        gap: 12px;
    }
    .deco-popover-controls .deco-control label {
        flex-basis: 70px;
        flex-shrink: 0;
    }
    .deco-popover-controls .style-btn-group {
        margin-left: auto;
    }
    .font-size-control {
      justify-content: space-between;
    }
    .stepper {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .stepper button {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: 1px solid #ccc;
        background-color: #f8f8f8;
        font-size: 1.2em;
        font-weight: bold;
        line-height: 1;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .stepper button:hover {
        background-color: #eee;
    }
    .stepper span {
        font-size: 14px;
        font-weight: 500;
        min-width: 40px;
        text-align: center;
    }
    
    /* テンプレートポップオーバー */
    .template-popover-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.4);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .template-popover-modal {
        background-color: var(--popover-bg);
        border-radius: 8px;
        padding: 8px;
        width: 90%;
        max-width: 250px;
        box-shadow: 0 4px 12px var(--popover-shadow);
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 80vh;
    }
    .template-list {
        list-style: none;
        padding: 0;
        margin: 0;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        max-height: 250px;
    }
    .template-list-item {
        padding: 10px;
        border-bottom: 1px solid #f0f0f0;
        cursor: pointer;
        transition: background-color 0.2s;
        word-wrap: break-word;
        position: relative;
        padding-right: 20px; /* アイコン用のスペース */
    }
    .template-list-item:last-child {
        border-bottom: none;
    }
    .template-list-item:hover {
        background-color: #f5f5f5;
    }
    .template-list-item.selected {
        background-color: #eef7ff;
        border-left: 3px solid var(--primary-color);
        font-weight: 500;
    }
    .template-list-placeholder {
        padding: 20px;
        text-align: center;
        color: #888;
    }
    .template-popover-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
    }

    /* スクロール用余白 */
    .scroll-buffer {
      display: none;
    }

    /* Responsive Styles for Mobile */
    @media (max-width: 800px) {
        html, body {
            height: 100%;
            overflow: hidden;
        }
        #root {
            padding: 0;
            height: 100vh;
        }
        .app-container {
            min-width: 100%;
            border-radius: 0;
            box-shadow: none;
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
        }
        .header {
            padding: 12px;
        }
        .header-top {
            flex-direction: column;
            align-items: stretch;
            gap: 12px;
        }
        .header-left {
            justify-content: space-between;
        }
        .id-control {
            width: 100%;
        }
        .id-control input {
            flex-grow: 1;
            min-width: 0;
        }
        .calendar-board {
            padding: 8px 4px;
        }
        .date-cell {
            min-height: 90px;
            padding: 4px;
        }
        .day-header {
            padding: 8px 0;
            font-size: 0.8em;
        }
        .date-number {
            font-size: 0.8em;
        }
        .date-number.today {
            width: 20px;
            height: 20px;
        }
        .label {
            font-size: 0.75em;
            padding: 3px 20px 3px 5px;
            min-height: 18px;
            width: calc(100% - 12px);
        }
        .label-link-icon {
            display: none; /* Hide link icon on mobile */
        }
        .label {
            padding-right: 6px; /* Adjust padding as icon is hidden */
        }
        #popover, #decoration-popover {
            left: 50% !important;
            bottom: 10px !important;
            top: auto !important;
            transform: translateX(-50%) !important;
            max-width: 90vw;
            width: auto;
        }
        #date-picker-popover {
            top: calc(100% + 8px) !important;
            left: 0 !important;
            transform: none !important;
            width: 100%;
            max-width: none;
            box-sizing: border-box;
        }
        .template-popover-modal {
            max-width: 95vw;
        }
        .scroll-buffer {
            display: block; /* モバイルでのみ表示 */
            height: 40vh; /* キーボードの高さを考慮した余白 */
            flex-shrink: 0;
        }
    }
  </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
  <div id="root"></div>
  <div id="popover" style="display: none;"></div>
  <div id="decoration-popover" style="display: none;"></div>
  <div id="template-popover-container"></div>
  <input type="file" id="file-importer" accept=".json" style="display: none;">

  <script>
    document.addEventListener('DOMContentLoaded', () => {

        // =================================================================================
        // Constants, State, and DOM Cache
        // =================================================================================

        const LOCAL_STORAGE_KEY = 'calendar-annotator-data';
        const DEFAULT_STYLE = {
            color: '#333333',
            backgroundColor: '#fffbe6',
            fontSize: '11',
            fontWeight: 'normal',
            fontStyle: 'normal',
        };

        const state = {
            currentDate: new Date(),
            labels: [],
            templates: [],
            currentId: '',
            activeLabelInfo: null,
            clipboard: null,
            dragInfo: null,
            isDatePickerVisible: false,
            datePickerYear: new Date().getFullYear(),
            isTemplatePopoverVisible: false,
            selectedTemplateId: null,
            isWheeling: false,
            longPressTimer: null,
        };

        const DOM = {
            root: document.getElementById('root'),
            popover: document.getElementById('popover'),
            decorationPopover: document.getElementById('decoration-popover'),
            templatePopoverContainer: document.getElementById('template-popover-container'),
            fileImporter: document.getElementById('file-importer'),
        };

        // =================================================================================
        // Helper Functions
        // =================================================================================
        
        const formatDate = (date) => {
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        };

        const getLabelStyle = (styleObj) => {
            if (!styleObj) return '';
            return `color: ${styleObj.color}; background-color: ${styleObj.backgroundColor}; font-size: ${styleObj.fontSize}px; font-weight: ${styleObj.fontWeight}; font-style: ${styleObj.fontStyle};`;
        };
        
        const getEventCoords = (e) => {
            const touch = e.touches?.[0] || e.changedTouches?.[0];
            if (touch) {
                return { x: touch.clientX, y: touch.clientY };
            }
            return { x: e.clientX, y: e.clientY };
        };

        const createLinkIconHtml = (link) => {
            if (!link || link.trim() === '') return '';
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M13.5435 10.4565L16.372 7.62803C18.2423 5.75771 21.2952 5.75771 23.1655 7.62803C25.0358 9.49835 25.0358 12.5512 23.1655 14.4215L20.337 17.25C18.4667 19.1203 15.4138 19.1203 13.5435 17.25L12.8364 16.5429C12.4459 16.1524 12.4459 15.5192 12.8364 15.1287C13.2269 14.7382 13.8601 14.7382 14.2506 15.1287L14.9577 15.8358C16.0692 16.9472 17.8288 16.9472 18.9402 15.8358L21.7687 13C22.8801 11.8885 22.8801 10.1289 21.7687 9.01748C20.6572 7.90602 18.8976 7.90602 17.7862 9.01748L14.9577 11.8459C14.5672 12.2364 13.934 12.2364 13.5435 11.8459C13.153 11.4554 13.153 10.847 13.5435 10.4565ZM10.4565 13.5435L7.62803 16.372C5.75771 18.2423 2.70481 18.2423 0.834492 16.372C-1.03583 14.5017 -1.03583 11.4488 0.834492 9.57847L3.66297 6.75C5.53329 4.87968 8.58619 4.87968 10.4565 6.75L11.1636 7.45711C11.5541 7.84763 11.5541 8.4808 11.1636 8.87132C10.7731 9.26185 10.1399 9.26185 9.74939 8.87132L9.04228 8.16421C7.93082 7.05275 6.17123 7.05275 5.05977 8.16421L2.23129 11C1.11983 12.1115 1.11983 13.8711 2.23129 14.9825C3.34275 16.094 5.10234 16.094 6.2138 14.9825L9.04228 12.1541C9.43281 11.7636 10.066 11.7636 10.4565 12.1541C10.847 12.5446 10.847 13.1778 10.4565 13.5435Z" /></svg>`;
            return `<span class="label-link-icon" contenteditable="false" data-action="open-link" data-link="${link}" title="${link}">${svg}</span>`;
        };
        
        const moveCursorToEndOfLabel = (labelEl) => {
            if (!labelEl) return;
            labelEl.focus();
            const selection = window.getSelection();
            if (!selection) return;
            const range = document.createRange();
            selection.removeAllRanges();

            const textNodes = Array.from(labelEl.childNodes).filter(n => n.nodeType === Node.TEXT_NODE);
            const lastTextNode = textNodes[textNodes.length - 1];

            if (lastTextNode) {
                range.setStart(lastTextNode, lastTextNode.length);
            } else {
                range.setStart(labelEl, 0);
            }
            range.collapse(true);
            selection.addRange(range);
        };
        
        const focusAndScrollToLabel = (labelEl) => {
            if (!labelEl) return;
            moveCursorToEndOfLabel(labelEl);
            showPopover(labelEl);

            // モバイルでキーボードが表示されることを想定し、要素が見える位置にスクロール
            if (window.innerWidth <= 800) {
                // 少し待ってからスクロールしないと、UIの描画やキーボードの出現と競合することがある
                setTimeout(() => {
                    labelEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100); 
            }
        };

        // =================================================================================
        // Data Persistence
        // =================================================================================

        const saveData = () => {
            try {
                const data = { labels: state.labels, templates: state.templates, currentId: state.currentId };
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.error("Failed to save data:", e);
            }
        };

        const loadData = () => {
            try {
                const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedData) {
                    const parsed = JSON.parse(savedData);
                    state.labels = parsed.labels || [];
                    state.templates = parsed.templates || [];
                    state.currentId = parsed.currentId || '';
                }
            } catch (e) {
                console.error("Failed to load data:", e);
                Object.assign(state, { labels: [], templates: [], currentId: '' });
            }
        };

        // =================================================================================
        // Popover Management
        // =================================================================================

        const saveOrDiscardActiveLabel = () => {
             if (!state.activeLabelInfo) return;

            const activeLabelEl = document.querySelector('.label.editing');
            if (activeLabelEl) {
                const newText = activeLabelEl.innerText.trim();
                const { type, id, date, top, left, style, link } = state.activeLabelInfo;

                if (type === 'new') {
                    if (newText) {
                        state.labels.push({ id: Date.now(), date, text: newText, top, left, style, link });
                        saveData();
                    }
                } else if (type === 'existing') {
                    const label = state.labels.find(l => l.id === id);
                    if (label) {
                        Object.assign(label, { text: newText, style });
                        saveData();
                    }
                }
            }
            state.activeLabelInfo = null;
        };
        
        const showPopover = (targetElement) => {
            if (!state.activeLabelInfo) return;
            DOM.popover.innerHTML = createPopoverHtml();
            DOM.popover.style.display = 'flex';
            
            const calendarBoard = document.getElementById('calendar-board');
            const calendarGrid = document.getElementById('calendar-grid');
            if (!calendarBoard || !calendarGrid) return; 

            const boardRect = calendarBoard.getBoundingClientRect();
            const gridRect = calendarGrid.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            const popoverRect = DOM.popover.getBoundingClientRect();
            const margin = 8;
            
            let top, left;
            
            const gridCenterX = gridRect.left + gridRect.width / 2;
            const targetCenterX = targetRect.left + targetRect.width / 2;
            const horizontalOffset = 40;
            left = targetCenterX - (popoverRect.width / 2) + (targetCenterX < gridCenterX ? horizontalOffset : -horizontalOffset);
            
            const spaceAbove = targetRect.top - boardRect.top;
            const popoverFitsAbove = spaceAbove > popoverRect.height + margin;
            top = (boardRect.bottom - targetRect.bottom > popoverRect.height + margin && !popoverFitsAbove)
                ? targetRect.bottom + margin
                : targetRect.top - popoverRect.height - margin;
            
            DOM.popover.style.top = `${Math.max(10, Math.min(top, window.innerHeight - popoverRect.height - 10))}px`;
            DOM.popover.style.left = `${Math.max(10, Math.min(left, window.innerWidth - popoverRect.width - 10))}px`;
        };

        const hidePopover = () => {
            saveOrDiscardActiveLabel();
            DOM.popover.style.display = 'none';
            hideDecorationPopover();
            render();
        };

        const showDecorationPopover = () => {
            if (!state.activeLabelInfo) return;
            const { style } = state.activeLabelInfo;

            DOM.decorationPopover.innerHTML = `
                <div class="deco-popover-header">
                    <span>装飾</span>
                    <button data-action="close-deco" aria-label="閉じる">&times;</button>
                </div>
                <div class="deco-popover-controls">
                    <div class="deco-control"><label for="deco-text-color">文字色</label><input type="color" id="deco-text-color" data-style-prop="color" value="${style.color}"></div>
                    <div class="deco-control"><label for="deco-label-color">ラベル色</label><input type="color" id="deco-label-color" data-style-prop="backgroundColor" value="${style.backgroundColor}"></div>
                    <div class="deco-control font-size-control">
                      <label>大きさ</label>
                      <div class="stepper">
                        <button data-action="decrease-font" aria-label="小さく">-</button>
                        <span id="deco-font-size-value">${style.fontSize}px</span>
                        <button data-action="increase-font" aria-label="大きく">+</button>
                      </div>
                    </div>
                    <div class="deco-control"><label>スタイル</label><div class="style-btn-group"><button data-style-prop="fontWeight" class="${style.fontWeight === 'bold' ? 'active' : ''}"><b>B</b></button><button data-style-prop="fontStyle" class="${style.fontStyle === 'italic' ? 'active' : ''}"><i>I</i></button></div></div>
                </div>`;
            DOM.decorationPopover.style.display = 'flex';

            const mainPopoverRect = DOM.popover.getBoundingClientRect();
            const activeLabelEl = document.querySelector('.label.editing');
            if (!activeLabelEl) return;
            const activeLabelRect = activeLabelEl.getBoundingClientRect();
            const decoPopoverRect = DOM.decorationPopover.getBoundingClientRect();
            
            let top, left;
            const gridCenterX = document.getElementById('calendar-grid').getBoundingClientRect().x + document.getElementById('calendar-grid').getBoundingClientRect().width / 2;
            
            left = (mainPopoverRect.left + mainPopoverRect.width / 2 < gridCenterX)
                ? mainPopoverRect.right - (decoPopoverRect.width / 3)
                : mainPopoverRect.left - (decoPopoverRect.width * 2 / 3);
            
            top = (mainPopoverRect.top < activeLabelRect.top)
                ? mainPopoverRect.top - decoPopoverRect.height + 30
                : mainPopoverRect.bottom - 30;

            DOM.decorationPopover.style.top = `${Math.max(10, Math.min(top, window.innerHeight - decoPopoverRect.height - 10))}px`;
            DOM.decorationPopover.style.left = `${Math.max(10, Math.min(left, window.innerWidth - decoPopoverRect.width - 10))}px`;
        };

        const hideDecorationPopover = () => {
            DOM.decorationPopover.style.display = 'none';
        };
        
        // =================================================================================
        // Core Rendering Logic
        // =================================================================================

        const render = () => {
            DOM.root.innerHTML = createAppHtml();
            const idInput = document.getElementById('calendar-id');
            if (idInput) idInput.value = state.currentId;
            renderTemplatePopover();
        };
        
        const createPopoverHtml = () => {
            const isNew = state.activeLabelInfo.type === 'new';
            const popoverTitle = isNew ? '新規ラベル' : 'ラベル編集';
            const pasteButtonDisabled = !state.clipboard ? 'disabled' : '';

            let buttonsHtml;
            if (isNew) {
                buttonsHtml = `
                   <button class="popover-btn" data-action="paste" ${pasteButtonDisabled}>貼付</button>
                   <button class="popover-btn" data-action="recall">呼出</button>
                   <button class="popover-btn" data-action="edit-link">リンク設定</button>
                   <button class="popover-btn" data-action="decorate">装飾</button>`;
            } else {
                const label = state.labels.find(l => l.id === state.activeLabelInfo.id);
                const link = label ? (label.link || '') : '';
                const openLinkButton = link
                    ? `<button class="popover-btn" data-action="open-link" data-link="${link}">リンクを開く</button>`
                    : '';

                buttonsHtml = `
                   <button class="popover-btn" data-action="duplicate">複写</button>
                   <button class="popover-btn" data-action="edit-link">リンク設定</button>
                   ${openLinkButton}
                   <button class="popover-btn" data-action="decorate">装飾</button>
                   <button class="popover-btn" data-action="save-template">テンプレ保存</button>
                   <button class="popover-btn" data-action="delete">削除</button>`;
            }

            return `
                <div class="popover-header">
                    <span>${popoverTitle}</span>
                    <button class="close-btn" data-action="close-popover" aria-label="閉じる">&times;</button>
                </div>
                <div class="popover-content">${buttonsHtml}</div>`;
        };


        const createAppHtml = () => {
            const { year, month } = { year: state.currentDate.getFullYear(), month: state.currentDate.getMonth() };
            return `
                <div class="app-container">
                  <header class="header">
                    <div class="header-top">
                      <div class="header-left">
                        <div class="date-picker-container">
                          <button class="header-title-btn" data-action="toggle-datepicker" aria-haspopup="true" aria-expanded="${state.isDatePickerVisible}">
                            ${year}年 ${month + 1}月
                          </button>
                          ${state.isDatePickerVisible ? createDatePickerPopoverHtml() : ''}
                        </div>
                        <div class="data-ops">
                           <button data-action="new">新規</button>
                           <button data-action="save-file">保存</button>
                           <button data-action="import-file">読込</button>
                        </div>
                      </div>
                      <div class="id-control"><label for="calendar-id">ID:</label><input type="text" id="calendar-id" placeholder="スケジュール名を入力"></div>
                    </div>
                  </header>
                  <main class="calendar-board" id="calendar-board">${createCalendarGridHtml()}</main>
                  <div class="scroll-buffer"></div>
                </div>`;
        };

        const createDatePickerPopoverHtml = () => {
            const months = [...Array(12).keys()];
            const isCurrentYear = state.currentDate.getFullYear() === state.datePickerYear;
            return `
            <div id="date-picker-popover">
                <div class="date-picker-header">
                    <button data-action="prev-year" aria-label="前の年">＜</button>
                    <input type="number" id="year-input" value="${state.datePickerYear}" aria-label="年を入力">
                    <button data-action="next-year" aria-label="次の年">＞</button>
                </div>
                <div class="month-grid">${months.map(m => `<button class="month-btn ${isCurrentYear && m === state.currentDate.getMonth() ? 'active' : ''}" data-action="select-month" data-month="${m}">${m + 1}月</button>`).join('')}</div>
                <div class="date-picker-footer"><button id="date-picker-today-btn" data-action="go-today">今日</button></div>
            </div>`;
        };

        const createCalendarGridHtml = () => {
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const start = new Date(firstDay);
            start.setDate(start.getDate() - firstDay.getDay());
            const end = new Date(lastDay);
            end.setDate(end.getDate() + (6 - lastDay.getDay()));

            let dates = [];
            for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                dates.push(new Date(d));
            }

            const headers = ['日', '月', '火', '水', '木', '金', '土'].map((day, i) => `<div class="day-header ${i === 0 ? 'sunday' : ''} ${i === 6 ? 'saturday' : ''}">${day}</div>`).join('');
            const cells = dates.map(date => createDateCellHtml(date, month)).join('');
            return `<div class="calendar-grid" id="calendar-grid">${headers}${cells}</div>`;
        };

        const createDateCellHtml = (date, currentMonth) => {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const isOtherMonth = date.getMonth() !== currentMonth;
            const isToday = date.getTime() === today.getTime();
            const isSunday = date.getDay() === 0;
            const isSaturday = date.getDay() === 6;
            const dateStr = formatDate(date);

            const cellCls = `date-cell ${isOtherMonth ? 'other-month' : ''}`;
            const numCls = `date-number ${isToday ? 'today' : ''} ${!isToday && isSunday ? 'sunday' : ''} ${!isToday && isSaturday ? 'saturday' : ''}`;
            
            const labelsHtml = state.labels.filter(l => l.date === dateStr).map(label => createLabelHtml(label)).join('');
            const newLabelHtml = (state.activeLabelInfo?.type === 'new' && state.activeLabelInfo.date === dateStr)
                ? createLabelHtml({ ...state.activeLabelInfo, id: 'temp-new-label' }, true)
                : '';

            return `<div class="${cellCls}" data-date="${dateStr}"><div class="${numCls}">${date.getDate()}</div><div class="labels-container">${labelsHtml}${newLabelHtml}</div></div>`;
        };

        const createLabelHtml = (label, isEditing = false) => {
            const isActuallyEditing = isEditing || (state.activeLabelInfo?.type === 'existing' && state.activeLabelInfo.id === label.id);
            const classes = `label ${isActuallyEditing ? 'editing' : ''}`;
            const idAttr = label.id === 'temp-new-label' ? 'id="temp-new-label"' : `data-id="${label.id}"`;
            const linkIconHtml = createLinkIconHtml(label.link);
            
            const displayText = (isActuallyEditing && !label.text) ? '&nbsp;' : label.text;

            return `<div class="${classes}" ${idAttr} contenteditable="${isActuallyEditing}" style="top: ${label.top}px; left: ${label.left}px; ${getLabelStyle(label.style)}">${displayText}${linkIconHtml}</div>`;
        };

        const renderTemplatePopover = () => {
            if (!state.isTemplatePopoverVisible) {
                DOM.templatePopoverContainer.innerHTML = '';
                return;
            }
            const listContent = state.templates.length > 0
                ? state.templates.map(t => {
                    const linkIcon = createLinkIconHtml(t.link);
                    return `<li class="template-list-item ${t.id === state.selectedTemplateId ? 'selected' : ''}" data-action="select-template-item" data-id="${t.id}" style="${getLabelStyle(t.style)}">${t.text}${linkIcon}</li>`;
                  }).join('')
                : '<div class="template-list-placeholder">保存されたテンプレートはありません。</div>';
            
            DOM.templatePopoverContainer.innerHTML = `
                <div class="template-popover-backdrop" data-action="close-template-backdrop">
                    <div class="template-popover-modal">
                        <ul class="template-list">${listContent}</ul>
                        <div class="template-popover-actions">
                             <button class="popover-btn" data-action="select-template" ${!state.selectedTemplateId ? 'disabled' : ''}>選択</button>
                             <button class="popover-btn" data-action="delete-template" ${!state.selectedTemplateId ? 'disabled' : ''}>削除</button>
                             <button class="popover-btn" data-action="close-template">閉じる</button>
                        </div>
                    </div>
                </div>`;
        };

        // =================================================================================
        // Action Implementations (Refactored from handleAction)
        // =================================================================================

        const handleNewCalendar = () => {
            if (state.labels.length > 0 && !confirm('現在のラベルをすべてクリアしますか？')) return;
            Object.assign(state, { labels: [], templates: [], currentId: '' });
            saveData();
            render();
        };

        const handleSaveFile = () => {
            state.currentId = document.getElementById('calendar-id').value.trim();
            if (!state.currentId) {
                alert('IDを入力してください。');
                return;
            }
            const dataStr = JSON.stringify({ labels: state.labels, templates: state.templates }, null, 2);
            const blob = new Blob([dataStr], { type: "application/json" });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${state.currentId}.json`;
            a.click();
            URL.revokeObjectURL(a.href);
        };
        
        const handleImportFile = () => DOM.fileImporter.click();
        const handleToggleDatePicker = () => { state.isDatePickerVisible = !state.isDatePickerVisible; render(); };
        const handlePrevYear = () => { state.datePickerYear--; render(); };
        const handleNextYear = () => { state.datePickerYear++; render(); };
        const handleGoToday = () => { state.currentDate = new Date(); state.isDatePickerVisible = false; render(); };
        
        const handleSelectMonth = (target) => {
            state.currentDate = new Date(state.datePickerYear, parseInt(target.dataset.month, 10), 1);
            state.isDatePickerVisible = false;
            render();
        };
        
        const handleOpenLink = (target) => {
            const link = target.dataset.link;
            if (link) { window.open(link, '_blank', 'noopener,noreferrer'); }
        };

        const handleDeleteLabel = () => {
            if (state.activeLabelInfo?.type === 'existing') {
                state.labels = state.labels.filter(l => l.id !== state.activeLabelInfo.id);
                saveData();
            }
            hidePopover();
        };

        const handleDuplicateLabel = () => {
            if (state.activeLabelInfo?.type === 'existing') {
                const label = state.labels.find(l => l.id === state.activeLabelInfo.id);
                if (label) state.clipboard = { text: label.text, style: { ...label.style }, link: label.link };
            }
        };

        const handlePasteToLabel = () => {
            if (state.activeLabelInfo && state.clipboard) {
                Object.assign(state.activeLabelInfo, { text: state.clipboard.text, style: { ...state.clipboard.style }, link: state.clipboard.link });
                render();
                setTimeout(() => {
                    const el = document.querySelector('.label.editing');
                    focusAndScrollToLabel(el);
                }, 0);
            }
        };

        const handleSaveTemplate = () => {
            const activeLabelEl = document.querySelector('.label.editing');
            if (state.activeLabelInfo?.type === 'existing' && activeLabelEl) {
                const label = state.labels.find(l => l.id === state.activeLabelInfo.id);
                if (label) {
                    state.templates.push({ id: Date.now(), text: activeLabelEl.innerText.trim(), style: { ...state.activeLabelInfo.style }, link: label.link });
                    saveData();
                    alert('テンプレートとして保存しました。');
                }
            }
        };
        
        const handleRecallTemplates = () => { state.isTemplatePopoverVisible = true; render(); };
        
        const handleEditLink = () => {
            if (!state.activeLabelInfo) return;

            const activeLabelEl = document.querySelector('.label.editing');
            if (activeLabelEl) {
                state.activeLabelInfo.text = activeLabelEl.innerText;
            }

            let currentLink = '';
            if (state.activeLabelInfo.type === 'existing') {
                const label = state.labels.find(l => l.id === state.activeLabelInfo.id);
                currentLink = label?.link || '';
            } else { // 'new'
                currentLink = state.activeLabelInfo.link || '';
            }
            const newLink = prompt('リンクURLを入力または編集してください:', currentLink);
            if (newLink === null) return;

            const trimmedLink = newLink.trim();
            if (state.activeLabelInfo.type === 'existing') {
                const label = state.labels.find(l => l.id === state.activeLabelInfo.id);
                if (label) label.link = trimmedLink;
            } else { // 'new'
                state.activeLabelInfo.link = trimmedLink;
            }
            
            render();
            setTimeout(() => {
                const el = document.querySelector('.label.editing');
                focusAndScrollToLabel(el);
            }, 0);
        };
        
        const handleSelectTemplateItem = (target) => {
            state.selectedTemplateId = Number(target.dataset.id);
            renderTemplatePopover();
        };

        const handleApplyTemplate = () => {
            if (state.activeLabelInfo && state.selectedTemplateId) {
                const template = state.templates.find(t => t.id === state.selectedTemplateId);
                if (template) Object.assign(state.activeLabelInfo, { text: template.text, style: { ...template.style }, link: template.link });
            }
            state.isTemplatePopoverVisible = false;
            render();
            setTimeout(() => {
                const el = document.querySelector('.label.editing');
                focusAndScrollToLabel(el);
            }, 0);
        };

        const handleDeleteTemplate = () => {
            if (state.selectedTemplateId) {
                state.templates = state.templates.filter(t => t.id !== state.selectedTemplateId);
                state.selectedTemplateId = null;
                saveData();
                renderTemplatePopover();
            }
        };

        const handleCloseTemplatePopover = () => {
            state.isTemplatePopoverVisible = false;
            render();
        };

        const handleFontSizeChange = (direction) => {
            if (!state.activeLabelInfo) return;
            let size = parseInt(state.activeLabelInfo.style.fontSize, 10);
            const min = 8;
            const max = 24;

            if (direction === 'decrease' && size > min) {
                size--;
            } else if (direction === 'increase' && size < max) {
                size++;
            } else {
                return; // No change
            }

            state.activeLabelInfo.style.fontSize = String(size);
            
            const valueEl = document.getElementById('deco-font-size-value');
            if (valueEl) valueEl.textContent = `${size}px`;

            const activeEl = document.querySelector('.label.editing');
            if (activeEl) activeEl.style.fontSize = `${size}px`;
        };
        
        // =================================================================================
        // Delegated Event Handlers
        // =================================================================================
        
        const handleGlobalClick = (e) => {
            // ドラッグ操作によるクリックは無視
            if (state.dragInfo?.hasMoved) return;

            const target = e.target;
            const actionTarget = target.closest('[data-action]');
            
            if (actionTarget) {
                if (actionTarget.dataset.action === 'close-template-backdrop' && target !== actionTarget) return;

                const action = actionTarget.dataset.action;
                const actionMap = {
                    'new': handleNewCalendar, 'save-file': handleSaveFile, 'import-file': handleImportFile,
                    'toggle-datepicker': handleToggleDatePicker, 'prev-year': handlePrevYear, 'next-year': handleNextYear,
                    'go-today': handleGoToday, 'select-month': () => handleSelectMonth(actionTarget),
                    'close-popover': hidePopover, 'open-link': () => handleOpenLink(actionTarget),
                    'delete': handleDeleteLabel, 'duplicate': handleDuplicateLabel, 'paste': handlePasteToLabel,
                    'save-template': handleSaveTemplate, 'recall': handleRecallTemplates, 'decorate': showDecorationPopover,
                    'edit-link': handleEditLink, 'close-deco': hideDecorationPopover,
                    'decrease-font': () => handleFontSizeChange('decrease'), 'increase-font': () => handleFontSizeChange('increase'),
                    'close-template-backdrop': handleCloseTemplatePopover, 'select-template-item': () => handleSelectTemplateItem(actionTarget),
                    'select-template': handleApplyTemplate, 'delete-template': handleDeleteTemplate, 'close-template': handleCloseTemplatePopover,
                };
                if(actionMap[action]) {
                    // リンクを開くアクションが他のクリック処理を妨げないように
                    if (action === 'open-link') e.stopPropagation();
                    actionMap[action]();
                }
                return;
            }

            const styleButton = target.closest('.style-btn-group button');
            if (styleButton && state.activeLabelInfo) {
                const prop = styleButton.dataset.styleProp;
                const current = state.activeLabelInfo.style[prop];
                const value = prop === 'fontWeight' ? (current === 'bold' ? 'normal' : 'bold') : (current === 'italic' ? 'normal' : 'italic');
                state.activeLabelInfo.style[prop] = value;
                styleButton.classList.toggle('active');
                
                const activeEl = document.querySelector('.label.editing');
                if (activeEl) activeEl.style[prop] = value;
                return;
            }

            if (target.closest('#popover, #decoration-popover, .date-picker-container, .template-popover-modal')) return;

            const clickedCell = target.closest('.date-cell');
            if (clickedCell && clickedCell.classList.contains('other-month')) {
                const [y, m, d] = clickedCell.dataset.date.split('-').map(Number);
                state.currentDate = new Date(y, m - 1, d);
                if (state.activeLabelInfo) hidePopover(); else render();
                return;
            }
            
            const wasEditing = !!state.activeLabelInfo;
            const clickedLabel = target.closest('.label');
            if (wasEditing && state.activeLabelInfo.id !== Number(clickedLabel?.dataset.id)) {
                 hidePopover();
                 return; // Popover was hidden, action for this click is complete.
            }

            if (clickedLabel) {
                const labelId = Number(clickedLabel.dataset.id);
                if (state.activeLabelInfo?.id === labelId) return;
                saveOrDiscardActiveLabel();
                const labelData = state.labels.find(l => l.id === labelId);
                state.activeLabelInfo = { type: 'existing', id: labelId, style: { ...labelData.style } };
                render();
                setTimeout(() => {
                    const el = document.querySelector(`.label[data-id="${labelId}"]`);
                    focusAndScrollToLabel(el);
                }, 0);
            } else if (clickedCell && !state.activeLabelInfo) {
                const dateStr = clickedCell.dataset.date;
                const labelsOnDate = state.labels.filter(l => l.date === dateStr).length;
                state.activeLabelInfo = {
                    type: 'new', date: dateStr, text: '', link: '',
                    top: 5 + labelsOnDate * 28, left: 5, style: { ...DEFAULT_STYLE }
                };
                render();
                setTimeout(() => {
                    const el = document.getElementById('temp-new-label');
                    focusAndScrollToLabel(el);
                }, 0);
            } else if (state.activeLabelInfo && !clickedLabel) {
                hidePopover();
            }
        };

        const handleGlobalInput = (e) => {
            const target = e.target;
            if (target.id === 'calendar-id') state.currentId = target.value;
            else if (target.id === 'year-input') {
                const year = parseInt(target.value, 10);
                if (!isNaN(year) && String(year).length >= 4) { state.datePickerYear = year; render(); }
            } else if (target.closest('#decoration-popover')) {
                const styleTarget = target.closest('[data-style-prop]');
                if (!styleTarget || !state.activeLabelInfo) return;
                const prop = styleTarget.dataset.styleProp;
                const value = styleTarget.value;
                state.activeLabelInfo.style[prop] = value;
                const activeEl = document.querySelector('.label.editing');
                if (activeEl) {
                    activeEl.style[prop] = value;
                }
            }
        };

        const handlePointerDown = (e) => {
            const labelEl = e.target.closest('.label');
            if (!labelEl || labelEl.isContentEditable) return;
            
            saveOrDiscardActiveLabel();
            
            const isTouchEvent = e.type === 'touchstart';
            if (isTouchEvent) {
                state.longPressTimer = setTimeout(() => {
                    labelEl.classList.add('drag-ready');
                    if (navigator.vibrate) navigator.vibrate(50);
                    
                    const rect = labelEl.getBoundingClientRect();
                    const coords = getEventCoords(e);
                    state.dragInfo = {
                        id: Number(labelEl.dataset.id), element: labelEl,
                        offsetX: coords.x - rect.left, offsetY: coords.y - rect.top,
                        hasMoved: false, startX: coords.x, startY: coords.y, isLongPress: true
                    };
                    state.longPressTimer = null;
                }, 350);
            } else { // Mouse event
                e.preventDefault();
                const rect = labelEl.getBoundingClientRect();
                const coords = getEventCoords(e);
                state.dragInfo = {
                    id: Number(labelEl.dataset.id), element: labelEl,
                    offsetX: coords.x - rect.left, offsetY: coords.y - rect.top,
                    hasMoved: false, startX: coords.x, startY: coords.y
                };
            }
        };
        
        const handlePointerMove = (e) => {
            if (state.longPressTimer) {
                clearTimeout(state.longPressTimer);
                state.longPressTimer = null;
            }
            if (!state.dragInfo) return;

            if (state.dragInfo.isLongPress) e.preventDefault(); // Prevent scroll only when dragging

            const coords = getEventCoords(e);
            if (!state.dragInfo.hasMoved) {
                if (Math.sqrt(Math.pow(coords.x - state.dragInfo.startX, 2) + Math.pow(coords.y - state.dragInfo.startY, 2)) < 5) return;
                state.dragInfo.hasMoved = true;
                const el = state.dragInfo.element;
                el.style.width = window.getComputedStyle(el).width;
                el.classList.add('dragging');
                document.body.appendChild(el);
            }
            state.dragInfo.element.style.top = `${coords.y - state.dragInfo.offsetY}px`;
            state.dragInfo.element.style.left = `${coords.x - state.dragInfo.offsetX}px`;
        };

        const handlePointerUp = (e) => {
            if (state.longPressTimer) {
                clearTimeout(state.longPressTimer);
                state.longPressTimer = null;
            }
            if (!state.dragInfo) return;

            const { hasMoved, element, id, offsetY, offsetX } = state.dragInfo;
            
            element.classList.remove('drag-ready');

            if (!hasMoved) {
                state.dragInfo = null;
                return; // Was a tap, click handler will manage.
            }
            
            const coords = getEventCoords(e);
            
            element.style.visibility = 'hidden';
            const targetCell = document.elementFromPoint(coords.x, coords.y)?.closest('.date-cell');
            element.style.visibility = 'visible';
            
            if (targetCell) {
                const containerRect = targetCell.querySelector('.labels-container').getBoundingClientRect();
                const label = state.labels.find(l => l.id === id);
                if (label) {
                    label.date = targetCell.dataset.date;
                    label.top = Math.max(0, coords.y - containerRect.top - offsetY);
                    label.left = Math.max(0, coords.x - containerRect.left - offsetX);
                }
            }
            element.remove();
            state.dragInfo = null;
            saveData();
            render();
        };

        const handleCalendarWheel = (e) => {
            if (e.target.closest('#popover, #decoration-popover, #date-picker-popover, .template-popover-modal')) return;
            e.preventDefault();
            if (state.isWheeling) return;
            state.isWheeling = true;
            state.currentDate.setMonth(state.currentDate.getMonth() + (e.deltaY < 0 ? -1 : 1));
            if(state.activeLabelInfo) hidePopover(); else render();
            setTimeout(() => { state.isWheeling = false; }, 100);
        };
        
        const handleFileImport = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const data = JSON.parse(event.target.result);
                    state.labels = (data && Array.isArray(data.labels)) ? data.labels : (Array.isArray(data) ? data : []);
                    state.templates = (data && Array.isArray(data.templates)) ? data.templates : [];
                    const fileName = file.name;
                    state.currentId = fileName.lastIndexOf('.') > 0 ? fileName.substring(0, fileName.lastIndexOf('.')) : fileName;
                    saveData(); render();
                    alert('データを読み込みました。');
                } catch (error) {
                    alert(`エラー：ファイルの読み込みに失敗しました。\n${error.message}`);
                } finally {
                    DOM.fileImporter.value = '';
                }
            };
            reader.readAsText(file);
        };

        // =================================================================================
        // Initialization
        // =================================================================================
        const initialize = () => {
            loadData();
            document.addEventListener('click', handleGlobalClick, true);
            document.addEventListener('input', handleGlobalInput);
            document.addEventListener('mousedown', handlePointerDown);
            document.addEventListener('touchstart', handlePointerDown, { passive: true });
            document.addEventListener('mousemove', handlePointerMove);
            document.addEventListener('touchmove', handlePointerMove, { passive: false });
            document.addEventListener('mouseup', handlePointerUp);
            document.addEventListener('touchend', handlePointerUp);
            DOM.root.addEventListener('wheel', handleCalendarWheel, { passive: false });
            DOM.fileImporter.addEventListener('change', handleFileImport);
            render();
        };

        initialize();
    });
  </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>